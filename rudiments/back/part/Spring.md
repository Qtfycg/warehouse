# Spring

## 1.Spring框架

```text
1.概述
    1.开源的轻量级Java开发应用框架，可以简化企业级应用开发。提供了功能强大IOC、AOP以及Web MVC等功能，且生态及其完善，是当前Java开发几乎不能缺少的框架之一。 
2.特点
    1.非侵入式:不会破还原有程序结构，反而可以进一步简化组件结构。
    2.面向切面编程(AOP):在不修改源代码的基础上增强代码功能。
    3.容器:Spring IOC是一个容器，包含并管理组件对象的生命周期。
    4.组件化:使用简单的组件配置组合成复杂的应用。
    5.一站式:在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。
    6.控制反转(IOC):翻转资源获取方向，把自己创建资源变成环境将资源准备好，我们享受资源注入。
3.核心容器
    1.IOC(控制反转)
        1.概念
            1.是一种思想。
            2.降低程序耦合度，提高程序扩展力。
            3.将对象的创建权力以及对象与对象之间关系的维护权利交给第三方容器(IOC容器)负责。
            4.通过依赖注入实现思想。
        2.在Spring的实现
            1.概念
                1.Spring的IOC容器即IOC思想落地的产品实现，其中管理的组件被称为Bean，创建Bean之前，需先创建IOC容器。
            2.实现方式
                1.BeanFactory
                    1.IOC容器的基本实现，是内部使用接口，面向Spring本身，不提供给开发人员使用。
                2.ApplicationContext
                    1.BeanFactory的子接口，提供更多高级特性，面向Spring的使用者
                    2.实现类
                        1.ClassPathXmlApplicationContext:读取类路径下的XML配置文件创建IOC容器对象。
                        2.FileSystemXmlApplicationContext:通过文件系统路径读取XML配置文件创建IOC容器对象。
                        3.ConfigurableApplicationContext:ApplicationContext的子接口，让ApplicationContext具有启动、关闭和刷新上下文的能力。
                        4.WebApplicationContext:专为Web应用准备，基于Web环境创建IOC容器对象，并存入ServletContext域中。
        3.bean管理
            1.基于XML管理bean
                1.获取bean
                    1.根据id获取
                        1.在xml文件中创建对象：<bean id="别名" class="全类名"></bean>
                        2.在类中获取对象
                            1.调用ApplicationContext对应的实现类
                            2.调用getBean("id")获取bean
                    2.根据类型获取bean
                        1.在xml文件中创建对象：<bean id="别名" class="全类名"></bean>
                        2.在类中获取对象
                            1.调用ApplicationContext对应的实现类
                            2.调用getBean(类型.class)
                        3.注意事项
                            1.IOC容器指定类型的bean有且只能有一个
                    3.根据id和类型获取bean
                        1.在xml文件中创建对象：<bean id="别名" class="全类名"></bean>
                        2.在类中获取对象
                            1.调用ApplicationContext对应的实现类
                            2.调用getBean("id"，类型.class)
    2.依赖注入(DI)
        1.概念
            1.Spring创建对象的过程中，将对象依赖属性通过配置进行注入
            2.类有属性，创建对象过程中，向属性设置值
        2.常见实现方式
            1.set注入
                1.创建类，定义属性，生成属性的set方法
                2.在xml文件中创建对象时，加上<property name="属性名" value="属性值"></property>
            2.构造注入
                1.创建类，定义属性，生成属性的无参和有参方法
                2.在xml文件中创建对象时，加上<constructor-arg  name="属性名" value="属性值"></constructor-arg>或者<constructor-arg  index="属性顺序" value="属性值"></constructor-arg>
            3.特殊值处理
                1.常量赋值
                    1.使用value属性给bean的属性赋值时，会把value属性的值看做常量
                2.null
                    1.加上<null></null>
                3.xml实体
                    1.特殊符号进行转义
                4.CDATA节
                    1.！[CDATA[属性值]]
                    2.当成字符处理
            4.特殊类型属性的注入
                1.对象类型
                    1.引用外部Bean
                        1.分别创建对象
                        2.使用<property name="属性名" ref="Bean的id值"></property>引入外部Bean
                    2.内部Bean
                        1.分别创建对象
                        2.将bean写在property里面
                    3.级联属性赋值(用的不多)
                        1.分别创建对象
                        2.使用<property name="属性名.方法" value="属性值"></property>
                        3.本质是通过get方法
                2.数组类型
                    1.分别创建对象
                    2.<property name="属性名"><array><value>属性值</value></array></property>（有几个属性值就有几个value标签）
                3.集合类型
                    1.List集合
                        1.分别创建对象
                        2.<property name="属性名"><list><ref bean="Bean的id值"></ref></list></property>（有几个属性值就有几个ref标签）
                    2.Map集合
                        1.分别创建对象
                        2.<property name="属性名"><map><entry><key>k值</key><ref bean="Bean的id值"></ref></entry></map></property>
                    3.引用集合类型
                        1.分别创建对象
                        2.使用 util:类型 定义(需要引入对应的命名空间)
                        3.引入定义的util，完成类型注入
            5.引入外部属性文件
                1.引入相关依赖
                2.创建外部属性文件(properties格式)
                3.创建Spring配置文件，引入属性文件
                    1.<context:property-placeholder location="外部属性文件位置"></context:property-placeholder>
                    2.完成对应信息注入
                    3.<property name="属性名" value="${配置文件里的属性名}"></property>
        3.bean的作用域
             1.scope(指定bean的作用域)
                1.singleton:单实例，每次获取的对象都相同
                2.prototype:多实例，每次获取的对象都不相同
                3.request:在一个请求范围类有效
                4.session:在一个会话范围类有效
        4.bean的生命周期
            1.bean对象创建:调用无参构造器
            2.相关属性注入
            3.bean后置处理器（初始化之前）
            4.bean对象初始化（调用指定的初始化方法）
            5.bean后置处理器（初始化之后，且需要放进ioc容器后才有用）
            6.bean对象创建成功
            7.bean对象销毁（调用指定的销毁方法）
            8.Ioc容器关闭
        5.FactoryBean
            1.概念
                1.Spring提供的一种整合第三方框架的常用机制
                2.配置此类型的Bean后，获取的对象是getObject()方法的返回值
                3.帮我们把复杂组件创建的详细过程与繁琐细节都屏蔽起来，只留下最简洁的使用界面
        6.基于xml自动装配
            1.利用autowire属性(基于set方法)
                1.byType：根据类型
                2.byNmae：根据名字
        7.基于注解自动装配
            1.概念
                1.代码中的一种特殊标记
                2.在编译、类加载和运行时被读取，执行对应处理
                3.不改变原代码和逻辑的基础上，嵌入补充信息
                4.格式:@注解名称(属性名称)
                5.可以使用在类、属性、方法上
            2.步骤
                1.引入依赖
                2.开启组件扫描
                    1.概念
                        1.默认不使用注解装配Bean，因此需要在XML文件中通过context:component-scan元素开启Spring Beans的自动扫描功能
                        2.会自动从扫描指定的包及其子包下所有的类，若类上有@Component注解，则将该类装配到容器中
                    2.步骤
                        1.修改XML文件的命名空间context
                        2.开启组件扫描的方式
                            1.开启组件扫描:<context:component-scan base-package="包名"></context:component-scan>
                            2.指定排除规则:<context:component-scan base-package="包名"><context:exclude-filter type="依据" expression="注解/类型的全类名"></context:exclude-filter></context:component-scan>
                                1.annotation:根据注解排除
                                2.assignable:根据类型排除
                            3.只扫描特定注解:<context:component-scan base-package="包名"><context:include-filter type="annotation" expression="注解的全类名"></context:include-filter></context:component-scan>
                3.使用注解定义Bean(创建对象)
                    1.@Component:描述Spring中的Bean，是一个泛化的概念，仅仅表示容器中的一个组件，且可以作用在应用的任何层次
                    2.@Repository:用于将数据访问层的类标识为Spring中的Bean，与@Component功能类似
                    3.@Service:用于将业务层的类标识为Spring中的Bean，与@Component功能类似
                    4.@Controller:用于将控制层的类标识为Spring中的Bean，与@Component功能类似
                4.属性注入
                    1.@Autowired:单独使用，默认根据类型装配
                        1.用处:构造方法、方法、形参、属性、注解
                        2.required属性
                            1.true:表示在注入的时候要求被注入的Bean必须是存在的
                            2.false:注入的Bean存不存在都没关系
                    2.@Resource
                        1.概念
                            1.是JDK扩展包里面的，为标准注解，更通用
                            2.默认根据名称装配。通过名称找不到时会自动启动通过类型装配
                            3.用在属性、setter方法上
                    3.全注解开发
                        1.不再使用Spring配置文件，使用配置类代替配置文件
                        2.对应注解
                            1.@Configuration:配置类
                            2.@ComponentScan("需要扫描的包名"):开启组件扫描
    3.AOP(面向切面编程)
        1.代理模式
            1.概念
                1.二十三种设计模式中的一种，属于结构性模式
                2.通过提供一个代理类，让我们在调用目标方法的时候，不是直接对方法进行调用，而是通过代理类间接调用，从而实现代码的解耦
            2.分类
                1.静态代理
                    1.被代理目标对象传递进代理类(构造方法)
                    2.确实实现了解耦，但代码写死，不具备灵活性
                2.动态代理(AOP底层实现)
                    1.概念
                        1.被代理目标对象传递进代理类(构造方法)
                        2.返回代理对象(新生成对应代理类):调用newProxyInstance方法
                    2.分类
                        1.JDK动态代理
                            1.目标类有接口的时候使用
                            2.生成的代理类会在com.sun.proxy包下，和目标类实现相同的接口
                            3.JDK原生实现方式，需要被代理的目标类必须实现接口
                        2.cglib动态代理
                            1.目标类没有接口时使用
                            2.生成的代理类会与目标类在相同的包下，会继承目标类
                            3.通过继承被代理的目标类实现代理，即不需要目标类实现接口
                        3.AspectJ
                            1.AOP思想的一种实现
                            2.本质是静态代理
                            3.将代理逻辑织入被代理的目标类编译得到的字节码文件，即最终实现效果是动态的
                            3.weaver就是织入器，Spring只是借用了其中的Aspectj注解
        2.AOP
            1.概念
                1.面向切面编程，是一种设计思想
                2.对面向对象编程的一种补充和完善，可以通过预编译的方式和运行期动态代理方式实现
                3.在不修改源代码的情况下，给程序动态添加额外功能
                4.能够使业务逻辑各部分之间的耦合度降低，提高程序的可重用性
            2.相关术语
                1.横切关注点
                    1.从每个方法中抽取出来的同一类非核心业务，分散在各个模块中解决同样的问题
                2.通知/增强
                    1.想要增强的功能
                    2.每一个横切关注点上要做的事都需要一个方法来实现，即通知方法
                        1.分类
                            1.前置通知:在被代理的目标方法前执行
                                1.@Before(value="execution(权限修饰符 方法返回值 方法所在类的全路径 方法名(参数列表))")
                                2.value：切入点表达式
                            2.返回通知:在被代理的目标方法成功结束后执行
                                1.@AfterReturning(value="execution(权限修饰符 方法返回值 方法所在类的全路径 方法名(参数列表))")
                                2.value：切入点表达式
                            3.异常通知:在被代理的目标方法异常结束后执行
                                1.@AfterThrowing(value="execution(权限修饰符 方法返回值 方法所在类的全路径 方法名(参数列表))")
                                2.value：切入点表达式
                            4.后置通知:在被代理的目标方法最终结束之后执行
                                1.@After(value="execution(权限修饰符 方法返回值 方法所在类的全路径 方法名(参数列表))")
                                2.value：切入点表达式
                            5.环绕通知:使用try···catch···finally结构围绕整个被代理的目标方法
                                1.@Around(value="execution(权限修饰符 方法返回值 方法所在类的全路径 方法名(参数列表))")
                                2.value：切入点表达式
                            6.复用切入点表达式
                                1.新建一个方法
                                2.使用@Pointcut(value="切入点表达式")
                                3.将对应的表达式改成方法名称
                3.切面
                    1.封装通知方法的类
                    2.优先级
                        1.优先级高的切面：外面，使用@Order(较小的数)
                        2.优先级低的切面：里面，使用@Order(较大的数)
                4.目标
                    1.被代理的目标对象
                5.代理
                    1.向目标对象应用通知之后创建的代理对象
                6.连接点
                    1.将方法排成一排，每一个横切位置看成x轴，方法从上到下执行看成y轴，x与y轴的交叉点即为连接点
                    2.即spring允许你使用通知的地方
                7.切入点
                    1.概念
                        1.定位连接点的方式
                        2.即实际去增强的方法
            3..作用
                1.简化代码
                2.代码增强
```

## 2.Spring Boot

```text

```

## 3.Spring MVC

```text
1.简介
    1.Spring的web模块，用来开发web应用
    2.最终作为B/S、C/S模式下的Server端
    3.核心就是处理HTTP请求响应
2.开发模式
    1.前后端不分离
    2.前后端分离
        1.注解
            1.@RequestMapping(路径映射)
                1.允许通配符(精确匹配优先)
                    1.*:匹配任意多个字符
                    2.**:匹配任意多层路径
                    3.？:匹配任意单个字符
                    4.精确路径全局唯一
                2.请求限定
                    1.method:请求方式
                        1.get、head、post、put
                        2.patch、delete、options、trace
                    2.params:请求参数
                    3.headers:请求头
                    4.consumes:请求内容类型
                    5.produces:响应内容类型
                3.请求参数处理
                    1.普通处理(同一个变量名获取)
                        1.在处理方法加上对应的形参
                        2.没有携带参数时，包装类型自动封装为null，基本类型封装为默认值
                    2.使用@RequestParam注解(在1的基础上)
                        1.参数必须携带
                        2.required = false:非必须携带
                        3.defaultValue:默认值
                    3.使用POJO、统一封装
                        1.请求参数放在请求体，也可以使用@RequestParam注解或同一个变量名获取
                        2.将形参改成对应的pojo
                        3.请求参数没带，封装为null
                        4.POJO的所有属性值都来自于请求参数
                    4.使用@RequestHeader获取请求头
                        1.形参为请求头中对应的属性
                    5.使用@CookieValue获取Cookie数据
                        1. 形参为请求头中对应的key值
                    6.使用POJO级联封装复杂属性
                        1.在对应的类中使用内部类，创建复杂属性
                    7.使用@RequestBody封装JSON
                        1.作用:获取请求体json数据，自动转换成对应的参数
                    8.文件上传
                        1.MultipartFile专门用来封装文件的请求参数
                        2.同时使用@RequestParam注解
                        3.调用对应的方法接收并保存图片
                        4.图片大小有限制1mb以内
                    9.获取整个请求(HttpEntity)
                        1.封装请求头与请求体
                        2.<>里为对应类型--泛型(可以自动转化)
                    10.传入原生API
                        1.将原生API作为请求参数
                4.响应参数处理
                    1.返回Json数据
                        1.返回对象，Spring MVC会自动转换成json
                        2.定死的写对象，定不死的写Map
                    2.文件下载
                        1.使用ResponseEntity
                        2.枚举类为字节流
                        3.contentType:文件类型
                        4.contentLength:文件大小
                        5.header:修改响应头
                            1.Content-Disposition:内容处理方式
                            2.attachment;filename:文件下载后名称
                            3.URLEncode.encode:文件编码
                            4.不要一口气读取所有文件，使用InputStreamResource转换
                    3.页面跳转
                    4.页面取值
            2.@RestController
                1.既能处理请求、又能返回数据
        2.RESTful
            1.概念
                1.表现层状态转移，是一种软件架构风格
                2.使用资源名作为URI，使用HTTP的请求方式表示对资源的操作
                3.满足REST风格的系统，称为是RESTful系统
            2.返回json参数
                1.code:业务是否成功(与前端商定)
                2.msg:错误提示信息
                3.data:返回给前端的数据
            3.跨域
                1.使用@CrossOrigin注解
                2.会发送俩次请求
                    1.options:预检请求，询问服务器是否允许当前域名进行跨域访问
                    2.真正的请求
            4.@PathVariable
                1.路径变量
        3.拦截器
            1.概念
                1.允许在请求被目标方法处理的前后进行拦截，执行一些额外操作
            2.步骤
                1.实现HandlerInterceptor接口的组件即可成为拦截器
                2.创建WebMvcConfigurer组件，并配置拦截器的拦截路径
            3.执行顺序
                1.preHandle顺序执行
                2.postHandle倒序执行
                3.afterCompletion倒序执行
                4.preHandle执行成功才会执行afterCompletion
                5.postHandle失败不影响afterCompletion
            4.与过滤器的区别
                1.拦截器是Spring定义的，而过滤器则是Servlet规范
                2.拦截器拦截SpringMVC能处理的请求，过滤器则拦截web的所有请求
        4.异常处理
            1.概念
                1.编程式异常处理
                    1.try-catch
                    2.throw
                    3.exception
                2.声明式异常处理
                    1.提供了@ExceptionHandle、@ControllerAdvice等便携的声明式注解来进行快速的异常处理
            2.相关注解
                1.@ExceptionHandle
                    1.精确优先
                    2.只负责本类中的异常
                2.@ControllerAdvice
                    1.负责全局异常
                    2.本类、精确优先
                    3.本类与全局都不能处理，Spring MVC提供默认的自适应处理机制
            3.最终方式
        5.数据校验
            1.概念
            2.相关注解
                1.JSR303
                    1.概念
                        1.Java为Bean数据合法性校验提供的标准框架
                        2.包含在JavaEE.0标准中
                        3.通过在Bean属性上标注相关注解实现
                    2.步骤
                        1.导入校验包
                        2.编写校验注解
                        3.开启校验注解
                        4. 使用异常全局处理器处理校验异常
                2.@Valid
                3.@BindingResult
```

## 4.Spring Security

```bash

```

## 5.Spring Cloud 组件

```text
1.基础
    1.单体架构
        1.所有的功能模块都在一个项目
        2.便于开发部署
        3.无法应对高并发
    2.集群架构
        1.将多台部署相同项目的设备集中到一起
        2.解决高并发问题
        3.产生模块化升级与多语言调用问题
    3.分布式架构
        1.一个大型应用被拆分成很多个小应用分布部署在各个机器上
2.组件
    1.Nacos
        1.概念
            1.易于构建云原生应用的动态服务发现，配置管理和服务管理平台
        2.功能
            1.注册中心
                1.服务注册
                    1.引入Nacos依赖
                    2.配置Nacos地址
                    3.启动类加@EnableDiscoveryClient
                    4.项目启动后自动在Nacos中注册
                2.远程调用
                    1.使用discoveryClient组件
                3.负载均衡
                    1.使用loadbalancer注解
            2.配置中心
                1.基本使用
                    1.启动Nacos
                    2.引入对应依赖
                    3.配置Nacos地址与导入配置文件
                    4.创建数据集
                2.动态刷新(先导入和外部优先)
                    1.@RefreshScope配置自动刷新
                    2.@configurationProperties配置无感刷新
                    3.NacosConfigManager通过编码的方式实现配置变化监听
                3.数据隔离
                    1.名称空间
                        1.区分多套环境
                    2.分组
                        1.区分多种微服务
                    3.数据集
                        1.区分多种配置
    2.OpenFeign
        1.概念
            1.声明式REST客户端，能实现远程调用
            2，注解驱动
        2.功能
            1.业务调用
                1.引入依赖
                2.主启动类加@EnableFeignClients开启远程调用
                3.创建远程调用服务接口
                4.使用@FeignClient标注
                    1.value值对应微服务名称
                5.编写对应接口
            2.第三方业务调用
                1.需要使用url精确指定请求发送地址
                2.MVC注解使用
                    1.在controller上是接受请求
                    2.在FeignClient上是发送这样的请求
                    3.小技巧
                        1.调用自己的业务api
                            1.将对方的controller签名复制粘贴过来
                        2.调用第三方业务api
                            1.参照第三方接口文档，如何发请求就如何定义
            3.日志
                1.将Feign接口所在的包的日志为debug级别
                2.在容器中放入LoggerLevel组件，声明日志记录的级别为FULL
            4.超时控制
                1.连接超时
                2.读取超时
            5.重试机制
                1.远程调用超时失败后，还可以进行多次尝试，如果某次成功返回ok，多次依然失败则结束调用返回错误。
            6.拦截器
            7.兜底返回
    3.Gateway
        1.功能
            1.统一入口
            2.请求路由
                1.路由规则
                    1.routes:
                        -id：路由名称
                        url：lb://微服务名称
                        predicates:
                            - Path=请求路径
                    2.断言(predicates)
                    3.过滤器(filter)
                    4.全局跨域
            3.负载均衡
            4.流量控制
            5.身份认证
            6.协议转换
            7.系统监控
            8.安全防护
    4.Seata
        1.
```
